function [temperatureSensor, timeVector] = simulateHeatDistribution(name)
%   
%   Simulates temperature evolution due to absorption of light and 
%   diffusion of heat through the tissue.
%
%   Define the power and the on- and off-duration of the light source, as
%   well as the starting temperature.
%   Define the number of times the temperatures should be extracted from
%   the simulation and plotted/recorded. Each update takes about 50-500 ms
%   to render depending on the number of voxels.
%   Note that the 3D matrices are defined in xyz-coordinates (and not yxz).
%
%   Input
%       name
%           the basename of the files generated by makeTissue.m and 
%           runMonteCarlo.m
%
%   Displays
%       Tissue cube
%       3D temperature evolution during illumination and diffusion
%       Temperature evolution for the individual temperature sensors (x-y-plot)
%       3D temperature distributions after illumination and after diffusion
%
%   Output
%       temperatureSensor
%           array containing the temperatures of the temperature sensors at
%           each timestep
%       timeVector
%           vector containing the times the temperatures were recorded
%
%       ./Data/[name]_heatSimOutput.mat
%           file containing 3D temperature distribution after illumination
%           and after diffusion as well as temperatureSensor, timeVector
%           and other input values
%
%   Requires
%       calcdtmax.m
%       plotVolumetric.m
%       finiteElementHeatPropagator.mex (architecture specific)
%

%% Updates
%   2014-01: Rasmus L. Pedersen & Mathias Christensen, DTU Fotonik
%   2017-06: Anders K. Hansen & Dominik Marti, DTU Fotonik


%% Load data from makeTissue.m and MonteCarlo.m
load(['./Data/' name '.mat']);
load(['./Data/' name '_MCoutput.mat'],'F');

%% Define parameters (user-specified)
Winc             = 1; % [W] Incident pulse peak power (in case of infinite plane waves, only the power incident upon the box' top area)
onduration       = 0.5; % [s] Pulse on-duration
offduration      = 0.5; % [s] Pulse off-duration
Temp             = zeros(size(T)); % [deg C] Initial temperature distribution
n_pulses         = 1; % Number of consecutive pulses, each with an illumination phase and a diffusion phase. If simulating only illumination or only diffusion, use n_pulses = 1.

plotTempLimits   = [0 16]; % [deg C], the expected range of temperatures, used only for setting the color scale in the plot
extremeprecision = false; % false: normal time step resolution (dt = dtmax/2), true: high time step resolution (dt = dtmax/100)
n_updates        = 20; % Number of times data is extracted for plots during each illumination phase and diffusion phase. Must be at least 1.

%% Determine remaining parameters
if n_pulses ~= 1 && (onduration == 0 || offduration == 0)
    n_pulses = 1; % If either pulse on-duration or off-duration is 0, it doesn't make sense to talk of multiple pulses
    fprintf('\nWarning: Number of pulses changed to 1 since either on-duration or off-duration is 0.\n\n');
end

[nx,ny,nz] = size(T);
nT = length(tissueList); % Number of different tissues in simulation

dx = x(2) - x(1);
dy = y(2) - y(1);
dz = z(2) - z(1);

HC = dx*dy*dz*[tissueList.VHC]; % Heat capacity array. Element i is the HC of tissue i in the reduced tissue list.
TC = [tissueList.TC]; % Thermal conductivity array. Element i is the TC of tissue i in the reduced tissue list.

%% Calculate time step
if extremeprecision
    dtmax = calcdtmax(T,TC,HC,dx,dy,dz)/100;
else
    dtmax = calcdtmax(T,TC,HC,dx,dy,dz)/2;
end

if onduration ~= 0
    nt_on = max(n_updates,ceil(onduration/dtmax)); % Number of time steps with illumination
    dt = onduration/nt_on; % Time step size
    if offduration ~= 0
        nt_off = max(n_updates,ceil(offduration/dt)); % Number of time steps without illumination
    else
        nt_off = 0;
    end
else
    nt_on = 0;
    nt_off = max(n_updates,ceil(offduration/dtmax)); % Number of time steps without illumination
    dt = offduration/nt_off; % Time step size
end

nt_vec = unique(floor([linspace(0,nt_on,n_updates+1) linspace(nt_on + nt_off/n_updates,nt_on + nt_off,n_updates)])); % Vector of nt's on which the plots should be updated

%% Calculate proportionality between voxel-to-voxel temperature difference DeltaT and time step temperature change dT
TC_eff = 2*(TC'*TC)./(ones(length(TC))*diag(TC)+diag(TC)*ones(length(TC))); % Same as TC_eff(i,j) = 2*TC_red(i)*TC_red(j)/(TC_red(i)+TC_red(j)) but without for loops
TC_eff(isnan(TC_eff)) = 0; % Neighboring insulating voxels return NaN but should just be 0
dTperdeltaT = cat(3,dt/dx*dy*dz*TC_eff./(diag(HC)*ones(nT)),dt*dx/dy*dz*TC_eff./(diag(HC)*ones(nT)),dt*dx*dy/dz*TC_eff./(diag(HC)*ones(nT))); % Third dimension corresponds to the different directions of heat diffusion
clear TC_eff

%% Calculate temperature change due to absorbed heat per time step
mua_vec = [tissueList.mua];
dT_abs = mua_vec(T).*F*dt*dx*dy*dz*Winc./HC(T); % Temperature change from absorption per time step [deg C] (mua_vec(T).*F is a 3D matrix of normalized volumetric powers)
clear F

%% Make plots to visualize tissue properties

% figure(2);clf;
% plotVolumetric(x,y,z,HC(T)/(dx*dy*dz));
% title('Volumetric heat capacity [J/(cm^3*K)]');
% figure(3);clf;
% plotVolumetric(x,y,z,TC(T));
% title('Thermal conductivity [W/(cm*K)]');

tissueFigure = figure(1); clf;
plotVolumetric(x,y,z,T,tissueList);
title('Tissue type illustration');

datacursormode on;
dataCursorHandle = datacursormode(tissueFigure);

fprintf('Place one or more (shift+click) temperature sensor in the tissue,\n and hit (almost) any key to continue...\n')
pause
cursorInfo = getCursorInfo(dataCursorHandle);
numTemperatureSensors = length(cursorInfo);

if numTemperatureSensors
    timeVector = [0 , repmat(nt_vec(2:end),1,n_pulses)+repelem(0:n_pulses-1,length(nt_vec)-1)*nt_vec(end)]*dt; % For temperature sensor plotting
    for temperatureSensorIndex = numTemperatureSensors:-1:1
        dataCursorPosition = cursorInfo(temperatureSensorIndex).Position;
        [~, dCPz] = min(abs(z-dataCursorPosition(3)));
        [~, dCPy] = min(abs(y-dataCursorPosition(2)));
        [~, dCPx] = min(abs(x-dataCursorPosition(1)));
        temperatureSensorPosition(temperatureSensorIndex) = ...
            sub2ind(size(T),dCPx,dCPy,dCPz);
    end
    temperatureSensorPosition = fliplr(temperatureSensorPosition); % Reverse array so the order of the sensors is the same as the order they were defined in.
    temperatureSensor = NaN(numTemperatureSensors,length(timeVector));
    temperatureSensor(:,1) = Temp(temperatureSensorPosition);
    
    temperatureSensorTissues = {tissueList(T(temperatureSensorPosition)).name};
    
    temperatureSensorFigure = figure(4); clf;
    temperaturePlot = axes('XLim',timeVector([1, end]));
    xlabel('Time [sec]')
    ylabel('Temperature [deg C]')
    title('Temperature evolution')
    hold on
    temperatureSensorLinePlots = plot(temperaturePlot,timeVector,temperatureSensor);
    for i=1:numTemperatureSensors
        temperatureSensorLinePlots(i).YDataSource = sprintf('temperatureSensor(%d,:)',i);
    end
    legend(temperatureSensorTissues);
else
    temperatureSensor = [];
    timeVector = [];
end

%% Prepare the temperature plot
heatsimFigure = figure(5);
plotVolumetric(x,y,z,Temp);
title('Temperature evolution');
caxis(plotTempLimits); % User-defined color scale limits

%% Simulate heat transfer
if numTemperatureSensors; figure(temperatureSensorFigure); end

fprintf('[nx,ny,nz]=[%d,%d,%d]. Number of pulses is %d.\nIllumination on for %d steps and off for %d steps in each pulse. Step size is %0.2e s.\n',nx,ny,nz,n_pulses,nt_on,nt_off,dt);

tic
for j=1:n_pulses
    if nt_on
        fprintf(['Illuminating pulse #' num2str(j) '... \n' repmat('-',1,n_updates)]);
    else
        fprintf(['Diffusing heat... \n' repmat('-',1,n_updates)]);
    end
    drawnow;
    for i = 2:length(nt_vec)
        Temp = finiteElementHeatPropagator(nt_vec(i)-nt_vec(i-1),Temp,T-1,dTperdeltaT,(nt_vec(i) <= nt_on)*dT_abs); % Arguments (nt,[[[Temp]]],[[[T]]],[[[dTperdeltaT]]],[[[dT_abs]]]). Contents of T have to be converted from Matlab's 1-based indexing to C's 0-based indexing.
        
        if numTemperatureSensors
            temperatureSensor(:,i+(j-1)*(length(nt_vec)-1)) = Temp(temperatureSensorPosition);
            refreshdata(temperatureSensorLinePlots,'caller');
        end
        
        fprintf(1,'\b');
        updateVolumetric(heatsimFigure,Temp);
        
        if nt_vec(i) == nt_on
            if n_pulses == 1
                Temp_illum = Temp;
            end
            fprintf('\b\b Done\n');
            if nt_off
                fprintf(['Diffusing heat... \n' repmat('-',1,n_updates)]);
            end
        elseif nt_vec(i) == nt_on + nt_off
            fprintf('\b\b Done\n');
        end
    end
end
toc;

%% Plot and save results
figure(heatsimFigure)
save(['./Data/' name '_heatSimoutput.mat'],'temperatureSensor','timeVector','Winc','onduration','offduration','Temp','n_pulses');
if ~nt_on
    title('Temperature after diffusion');
elseif ~nt_off
    title('Temperature after illumination');
elseif n_pulses == 1
    title('Temperature after diffusion')
    figure(6);
    plotVolumetric(x,y,z,Temp_illum);
    title('Temperature after illumination');
    save(['./Data/' name '_heatSimoutput.mat'],'Temp_illum','-append');
else
    title(['Temperature after ' num2str(n_pulses) ' pulses'])
end
fprintf('./Data/%s_heatSimoutput.mat saved\n',name);

return
